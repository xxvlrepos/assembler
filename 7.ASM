CSEG segment
assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG
org 100h
Begin:
    call Wait_key ;ждем нажатия клавиши...
    cmp al,27	  ;это <Esc>?
    je Quit_prog
    cmp al,0	  ;код клавиши расширенный? (<F1>-<F12> и т. п.)
    je Begin	  ;да — повторим запрос...
		  ;Вызываем процедуру вывода нажатой клавиши на экран
    call Out_char
    jmp Begin	  ;ждем дальше...
		  ;Метка, на которую придет программа в случае нажатия клавиши <Esc>
Quit_prog:
    mov al,32	  ;помещаем в al <пробел>
		  ;Вызываем процедуру вывода символа в al (в данном случае — пробела).
		  ;Здесь мы как бы "обманываем" процедуру Out_char, которая нужна для вывода
		  ;нажатого символа на экран. Мы симулируем нажатие клавиши <Пробел>
    call Out_char
    int 20h	  ;выходим в DOS...
 
 === Подпрограммы ===
 --- Wait_key ---
Wait_key proc
    mov ah,10h
    int 16h
    ret Wait_key endp
 
 --- Out_char --- ;процедура (комментарий)
Out_char proc      ;начало процедуры
		   ;Сохраним все регистры, которые будут изменены подпрограммой...
    push cx
    push ax
    push es	   ;сохраним сегментный регистр
 
    push ax	   ;сохраним ax, т. к. в нем код нажатой клавиши...
    mov ax,0B800h  ;установим es на сегмент видеобуфера
    mov es,ax
    mov di,0	   ;di — первый символ первой строки
		   ;Выводим 2000 символов (80 символов в строке * 25 строк
    mov cx,2000
    pop ax	   ;восстановим код клавиши (см. строку 18)...
    mov ah,31	   ;цвет символа
		   ;Метка для цикла, который выполнится 2000 раз (количество повторов
		   ;задается в строке 22)

Next_sym:	   ;Заносим код клавиши и ее цвет (цвет всегда 31)
    mov es:[di],ax ;Увеличиваем указатель на 2 (первый байт — символ, второй байт — цвет)
    inc di
    inc di
    loop Next_sym  ;обработка следующего символа
		   ;Восстановим сохраненные регистры и выровняем стек
    pop es
    pop ax
    pop cx
    ret 	   ;вернемся из подпрограммы
Out_char endp
 
CSEG ends
end Begin